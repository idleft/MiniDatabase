
[ RBFM Layer ]

deleteRecords
--------------
At first, it closes this file and detroy it. And it create this file and open it to make
sure the same file exist with no value. We call PFM layer APIs to complete the job.

deleteRecord
--------------
In deleteRecord, we set slot->begin to -1 - slot->begin, which indicates this record
is deleted. If the record we want to delete is tombstone, we delete
all the tombstones linked to this record. By setting slot begin to be minus value,
this record will not be accessed by reading record function.

updateRecord
--------------
when updating a record, we first calculte the updated record size.
1. If its size is equal to the original record, we update the record inplace directly.
2. If the new record size is smaller than orginal record, we update the record at the 
original place, and shift the data records behind to occupy the free space. 
3. If the new record size is bigger than orginal record, we first run reorganize the page.
If the reorganized page has enough free space, we run as 2). If not, we insert the updated
record as a new record, and set the orginal record as tombstone with pointer to the new updated
record.

readAttribute
--------------
First, try to measure size of record to read by calling getEstimatedRecordDataSize. Then it reads
record with record description. Once reading data completes, we extract attributes from data.

reorganizePage
--------------
Reorganize page go over all record in current page. If meet delete record, shift all data behind to 
occupy the delete record space. If meet tombstone, shrink the tombstone data to only contain 
tombstone marker and pointer to new record.

Scan Iterator
--------------
It first initializes condition variablesby calling initialize API. By calling getNextRecord,
it first reads record, checks given condition, and generates data. To access data,
we go over attribute and compare condition. 

[ RM Layer ]

createTable / deleteTable
--------------
We reserved "Tables.tbl" , "column.tbl", "index.tbl" to store catalog information.
If a user wants to create/delete these tables, we just print errors. By creating table, a user can
insert an entry of Table, column, and index to a catalog file. By deleting a table,
a user can delete Table, column, and index record.

getAttributes
--------------
By accessing table ID Map, it can access each table's attributes. By calling readRecord API, 
it is allowed to read a record and format it into column with descriptor.

insertTuple/deleteTuples/deleteTuple
--------------
With given table name, it inserts/deletes record with attribute description. By deleting tuples,
we destroy file storing records.


updateTuple
--------------
With given table name, it first gets attributes for the table and update record with given table description. 


readTuple
--------------
At first, trying to check whether table name is in the table name map. If it does, retrieve attributes for
the table name. Afterwards, read record with table attributes and return the value.


readAttribute
--------------
Once opening the table file, we retrieve attributes from the table file. Afterwards, read each attribute
matching record descriptor. While doing this, we try to check whether the field type is matched or not.

reorganizePage
--------------
By trying to allocate a new page, we reorganize previous page.
If there is a space saying deleted record was here (slot->begin value is minus), then we try to copy slot begin
and end information to new slot information. If data is there, then we copy data to the new page with size of
the data itself. We do this recursively for an entire page. And finally write reorganized page to disk.

scan
--------------
First, we try to find reserved table names, such as Tables and Columns. If this is the case, we simply initialize
iterator with condition and attribute values. If table name is not same as reserved names, we first trying to
retrieve attributes with record descriptors.   

createTableCatalog
--------------
This API adds table attributes to defined vector. It includes tableID, tableName, fileName, and numOfColumns.

createColumnCatalog
--------------
It adds column attributes to defined vector. It includes tableID, tableName, columnStart, columnName, 
columnType, and maxLength.

createIndexCatalog
--------------
It adds index attributes to defined vector. Currently it is not supported for project 2.

loadCatalog
--------------
It loads Tables and Column catalog into the memory. To be specific, we try to load table ID map and colum ID map.
From here, we can execute tuple operations. ScanIterator finds data by calling getNextTuple API.

insertTableEntry
--------------
It allocates memory for table entry and copy table attribute values to the allocated memory. Once it is formatted to
record, we insert this table record.

insertColumnEntry
--------------
It allocates memory for column entry and copy table attribute values to the allocated memory. Once it is formatted to
record, we insert this column record.

getCatalogSize
--------------
By catalog vector description, it tries to add length of based on data type.

createCatalogFile
--------------
It creates catalog file based on table name parameter. After creating a file, it inserts a table entry and column entry.

colDescriptorToAttri
--------------
It takes column descriptor which is memory with values as an input and extract each attribute. After extarcting each attribute
based on format type, it copied to Attribute structure.

 